import hashlib
import SHA_256
import encryption
import RSAencryption
import json


#-----------------implmented digital signature without hashing the certificate, because our RSA keys are not 256 bits and hence
#-----------------our 'n' value and other key values are less than 256 bits which gives us incorrect encryption and decryption
#-----------------However, we are using the hash value of cartificate to store in our "certifiates" array of our CA
class CertificateAuthority:
    def __init__(self):
        self.root_private_key, self.root_public_key = self.generate_key_pair()
        self.certificates = {}

    def generate_key_pair(self):
        return encryption.RSAkeygeneration(8)

    def generate_certificate(self, subject_name, public_key):
        certificate = {
            'subject': subject_name,
            'public_key': public_key
        }
        certificate_bytes = str(certificate).encode()
        certificate_hash = SHA_256.sha256(certificate_bytes)
        #-------------------encrypting the integer 256 Hash value of the certifcate for digital signature----------
        #signature =RSAencryption.create_sig(certificate_hash,self.root_private_key)
        
        #-------------------encrypting the certificate content as string for digital signature----------
        # certificate_json = json.dumps(certificate)
        # signature=encryption.create_sig(certificate_json, self.root_private_key)

        #-------------------encrypting the certificate hash as string for digital signature----------
        certificate_hash_str=str(certificate_hash.hex())
        signature=encryption.create_sig(certificate_hash_str, self.root_private_key)

        self.certificates[certificate_hash] = (certificate, signature)


        return certificate, signature
    

    def verify_certificate(self, certificate, signature):
        certificate_bytes=str(certificate).encode()
        certificate_hash = SHA_256.sha256(certificate_bytes)

        #-------------------decrypting the integer 256 Hash value of the certifcate for digital signature----------
        #valid=RSAencryption.verify_sig(certificate_hash,signature,self.root_public_key)

        #-------------------decrypting the certificate content as string for digital signature----------
        # certificate_json=json.dumps(certificate)
        # valid=encryption.verify_sig(certificate_json, signature, self.root_public_key)

        #-------------------decrypting the certificate hash as string for digital signature----------
        certificate_hash_str=str(certificate_hash.hex())
        valid=encryption.verify_sig(certificate_hash_str, signature, self.root_public_key)


        if valid==True:
            print("Certificate is valid.")
        else:
            print("Certificate is not valid.")
        return valid
    
    def Root_public_key(self):
        return self.root_public_key
    
    def get_user_public_Key(self,certificate,user_signature):
        is_valid=self.verify_certificate(certificate,user_signature)
        if(is_valid):
            certificate_bytes = str(certificate).encode()
            certificate_hash = SHA_256.sha256(certificate_bytes)
            user_certificate, user_signature = self.certificates[certificate_hash]
            user_public_key = user_certificate['public_key']
            return user_public_key
        else:
            return None


        

# Example usage
if __name__ == '__main__':
    pki = CertificateAuthority()

    alice_private_key, alice_public_key = pki.generate_key_pair()
    print("Alice's public key: ", alice_public_key)
    print("Alice's private key: ", alice_private_key)

    alice_certificate, alice_signature = pki.generate_certificate('Alice', alice_public_key)
    # Verification, will give the public key after certificate is valid and generated by the CA
    print(pki.get_user_public_Key(alice_certificate,alice_signature))
 